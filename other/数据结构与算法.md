# 数据结构与算法

## 一、基础

### 1.1、时间复杂度

#### 1.1.1、操作单元

程序执行的一个最基本的操作。例如获取数组中第 i 个元素的值，只需计算它的偏移量即可；跳转一次链表，指向下一个单元；执行一次交换操作等。

#### 1.1.2、时间复杂度

**估算**的执行程序所需的**执行操作单元的次数**，以选择排序为例，计算选择排序算法的时间复杂度。

选择排序是遍历一边数组，找出数组中数值最小的一项，与第一项交换，然后从第二项开始再次找到最小的元素，与第二项交换，以此类推，直到最后。

那么算法需要执行

1.   遍历操作数为 `1 + 2 + 3 + ... + n` 次，一共是 `[n(n+1)]/2` 次。

2.   比较次数与上面一样 `[n(n+1)/2]` 次

3.   交换操作 n 次。

     一共是 $n^2 + 2n$ 次，保留最高项，去掉最高项的系数，所以选择排序的事件复杂度为 $O(n^2)$ 。

     >   当数据量很大的时候，舍去的项就显得非常微小了，所以这也是只保留最高项的原因。
     >
     >   当两个时间复杂度相同的算法比较好坏时，需要分析不同样本下程序运行所需要的事件。

### 1.2、排序算法

#### 1.2.1、选择排序

第 i 次循环，找出index >= i 中值最小的项，与第 i 项交换（i = 0, 1, 2, ..., N）

>   C/C++

```c++
// 交换两个元素
int* swap(int arr[], int i, int j){
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

int* selectionSort(int arr[], int length){
    // 排除空数组和长度为1 的数组
    if (arr == nullptr || length < 2) {
        return arr;
    }
	// 循环开始
    for (int i = 0; i < length; i++) {
        // 最小值的 index
        int minIndex = i;
        for (int j = i; j < length; j++) {
            // 比较一下，更新最小值的索引
            if (arr[minIndex] > arr[j]) {
                minIndex = j;
            }
        }
        swap(arr, minIndex, i);
    }
    return arr;
}
```

#### 1.2.2、冒泡排序

第一次循环，依次比较第 1，2个；2，3个；3，4个；...；N - 1个，N个元素的大小，不符合排序顺序的就交换。

第二次循环，依次比较第 1，2个；2，3个；3，4个；...；N - 2个，N - 1个元素的大小，不符合排序顺序的就交换。

第二次循环，依次比较第 1，2个；2，3个；3，4个；...；N - 3个，N - 2个元素的大小，不符合排序顺序的就交换。

...

>   C/C++

```c++
int* swap(int arr[], int i, int j){
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

int* bubbleSort(int arr[], int length) {
    for (int i = 0; i < length - 1; i++) {
        for (int j = 0; j < length - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr, j, j + 1);
            }
        }
    }

    return arr;
}
```

#### 1.2.3、插入排序

从左到右逐步实现有序，就像打扑克整理牌一样。

第一步，实现 0 - 0 有序，必然是有序的，可以跳过

第二步，实现 0 - 1 有序，如果 arr1 < arr0，则交换。

第三步，实现 0 - 2 有序，如果arr2 < arr1，交换；再继续向前比较，如果还是arr2（这个时候已经变成arr1了）小，继续交换，以此类推...

...

直到第N步，实现整个数组的排序。

```java
public static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

public static void insertSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {
            swap(arr, j, j + 1);
        }
    }
}
```

#### 1.2.4、插入排序的时间复杂度

如果考虑最好的情况，就是排序好的数组，每次循环只需看一下，不满足循环条件就到下一次循环。这种情况的时间复杂度是O(N)。

如果是最坏的情况，与预期排序的顺序完全相反，那么第 i 次循环救药执行 i 次，就是1 + 2 + 3 + ... + N，这个时间复杂度就是 $O(N^2)$ 。

算法时间复杂度只考虑最坏的情况。

### 1.3、交换

#### 1.3.1、普通交换

使用一个中间变量暂时存储其中一个变量，这个变量把另一个变量存储好后，就把临时变量赋值给另一个变量。

```c++
int* swap(int arr[], int i, int j){
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

#### 1.3.2、加法交换

变量1存储两个数的和，然后把变量1减变量2的结果赋值给变量2，最后把变量1减去变量2的结果赋值给变量1。

```c++
int* swap(int arr[], int i, int j){
    arr[i] = arr[i] + arr[j];
    arr[j] = arr[i] - arr[j];
    arr[i] = arr[i] - arr[j];
}
```

不需要借助临时变量。

#### 1.3.3、异或交换

##### 1.3.3.1、异或

异或用符号 `^` 表示，同位的数字相同为0，不同为1。

```
a   111010
b   010111
^   101101
```

##### 1.3.3.1、异或特性

1.   任何值异或0都是本身
2.   任何值与自己异或都是0
3.   满足交换律和结合律

##### 1.3.3、交换

```
int* swap(int arr[], int i, int j){
    arr[i] = arr[i] ^ arr[j];
    arr[j] = arr[i] ^ arr[j];
    arr[i] = arr[i] ^ arr[j];
}
```

原理：

第一步 `arr[i] = arr[i] ^ arr[j];`

第二步 `arr[j] = arr[i] ^ arr[j] = arr[i] ^ arr[j] ^ arr[j] = arr[i] ^ 0 = arr[i];`

第三步 `arr[i] = arr[i] ^ arr[j] = arr[i] ^ arr[j] ^ arr[i] = arr[j] ^ 0 = arr[j];`

注意：**这种方法必须保证交换的双方指向的不是同一块内存地址。不推荐使用**

位操作的速度比一般加减乘除快。

##### 1.3.4、相关题目

1.   给一个数组，里面包含一个出现奇数次的数和其他出现偶数次的数，请你找出这个出现奇数次的数。

解法：定义一个变量 `eor = 0;` 然后与数组中的每一个数都异或，得到的结果就是出现奇数次的数。

因为**出现偶数次的数**以及**出现奇数次中的偶数部分**异或之后都为 0，在异或一次出现奇数次的数就得到结果了。

```c++
int oneOdd(int arr[], int length) {
    // 初始值为 0
    int eor = 0;
    for (int i = 0; i < length; i++) {
        eor ^= arr[i];
    }

    return eor;
}
```

2.   给一个数组，里面包含两个出现奇数次的数和其他出现偶数次的数，请你找出这两个出现奇数次的数。

解法：首先还是定义一个 `eor = 0` ，先异或一遍数组，得到的结果是 `eor = a ^ b;` （假设这两个数是a和b，a != b），

那么这两个数肯定有某个位置是不相同的，而这些位置在eor中就是1所在的位置。我们根据其中一个不相同的位置将数据划分为两个部分，定义一个变量 `eor2 = 0` 异或一遍其中一部分，得到的就是其中的 a 或 b，最后再把 `eor ^ eor2` 得到另一个数。

```c++
int* twoOdd(int arr[], int length) {
    int eor = 0;
    for (int i = 0; i < length; i++) {
        eor ^= arr[i];
    }

    int eor2 = 0;
    // 重要的一步，得到eor最右边为1的数。
    int rightOne = eor & (~eor + 1);
    for (int i = 0; i < length; i++) {
        // 将每一个数都与 rightOne 按位与
        // 如果那个位置是 0，则结果为 0，写 != 也是一样，目的是分开数据。
        if ((arr[i] & rightOne) == 0) {
            eor2 ^= arr[i];
        }
    }
    printf("%d, %d\n", eor2, (eor ^ eor2));
}
```

假设第一次循环得到的eor是 `1 0 0 1 0 0` ，`int rightOne = eor & (~eor + 1);` 这一步做的就是：

1.   eor取反 `0 1 1 0 1 1`
2.   加一 `0 1 1 1 0 0`
3.   再和最初的eor相与 `0 0 0 1 0 0` ，这样就得到了 a 和 b 最右边不相同位的数字。

4.   之后数组中每个数字都与这个数字相与，那么倒数第三位为 1 的就不为0，为0的就等于0，这样就把两种数字区分开了。

### 1.4、二分查找

#### 1.4.1、有序数组二分查找

对于有序数组，从从查找一个数字的位置可以使用二分查找的方法。

第一步，设置left和right以及middle，middle就是left + right / 2，将要查找的值与第 middle 个值进行比较，如果要查的值比较小，就更新right，如果要查的值计较大，就更新left。最后再更新middle。

然后一直重复上面的步骤，直到找到那个值的位置，或者left > right。

```java
public static int binarySearch(int[] arr, int value) {
    int left = 0;
    int right = arr.length - 1;
    while (left <= right) {
        int middle = (left + right) / 2;
        if (arr[middle] > value) {
            right = middle - 1;
        } else if (arr[middle] < value) {
            left = middle + 1;
        } else {
            return middle;
        }
    }
    return -1;
}
```

#### 1.4.2、二分查找的时间复杂度

二分查找的最复杂的情况就是查找到left > right，也就是 log(N)。因为每循环一次就去掉现有区域的一半。例如 8 4 2 1。

#### 1.4.3、扩展

1.   给一个有序数组，查找大于x的最左侧的值的索引。

使用二分查找的思路就是，先用一个临时变量存储最接近目标值的索引，然后继续查找有没有更接近的，如果middle所指的值比指定的值要大，那么就更新临时变量，如果比指定值小（或相等），就不变。最后更新left，right，middle，直到left > right。

与一般二分查找不同的是，这个二分查找一定要搜索到底。

```java
```

2.   找出（无序）数组中一个局部最小值。

如果第一个数字比第二个小，第一个值就是局部最小值。同理最后一个比倒数第二个小，也是局部最小值。

第 i 个值小于第 i - 1 个，也小于 第 i + 1 个，他也是局部最小值。

假如满足arr[0] < arr[1] 就返回零，否则查看 arr[N - 1] < arr[N - 2]，如果满足，返回 N - 1，否则进入下一步。

如果上面两个都不满足，那么这个数组两端就是翘的，`\ ..... /` ，其中肯定有局部最小值点。

如果是 `\.../m/.../` 或者 `\.../m\.../` ，如果左侧较小，那么左边肯定有最小值点如果右侧较小，右边肯定有最小值点，如果两个条件都没有满足，那么middle就是最小值点。

```java
```

### 1.5、对数器

当你有两个方法a和b，他们都能解决这个问题，一个是你想测试的方法a，一个是复杂度高但是容易实现的方法b，实现一个随机样本产生器，把方法a和b跑进同样的随机样本，看看得到的结果是否一样，如果有一个随机样本使对比结果不一致，打印样本进行认供干预，改对方法a或b，当样本数量很多时对比测试依然正确，可以确定方法a已经正确。

生成一个 随机大小，值也随机的数组，让这两个算法都跑一遍。

## 二、基础提升

### 2.1、哈希函数与哈希表等

#### 2.1.1、哈希函数

1.   哈希函数是一个将无穷范围的数据集映射到一个有限范围的函数。

2.   对于同一个输入数据，它的输出结果是相同的，也就是结果不是随机的。

3.   对于不同的输入数据，它的输出结果一定不相同。（因为无穷映射到有穷，一定会出现重复的哈希值，但是这个出现的概率是微乎其微，几乎没有。）

常见的哈希函数有MD5（输出范围 $0 至 2 ^ {64}  - 1$）、SHa1（输出范围是 0 至 2^128 - 1），写成十六进制分别是16位和32位。

4.   对于生成的哈希值是均匀分布的，即使是非常相似的输入，得到的哈希值也毫无规律。

#### 2.1.2、哈希表

根据哈希函数的离散性，可以设计出哈希表。它是一个链表的数组，每个链表的头组成数组，后面跟上链表，像一面旗一样。对于新添加的元素，计算出哈希值后，再模数组的长度就将其分配到了不同的链表中。由于哈希函数的离散性，它模数组长度之后在链表中是均匀分布的，取值时，按照同样的步骤算出在哪个链表再搜索。如果链表的长度过长会降低哈希表的效率，所以这个一般不会太长。

当哈希表的某一个链达到一定的长度后，就可以认为其他链也几乎达到了相同的长度，再向里面添加时就需要扩容。对于N个数组，需要扩容 logN 次，每次扩容都需要将所有的数据重新计算哈希，重新分配，所以扩容的复杂度为O(NlogN)，所以对于每个元素的添加复杂度为 O(logN)。在实际使用时，由于链表的长度和其他优化，它的复杂度是远远小于 O(logN)，而接近 O(1)。

#### 2.1.2、布隆过滤器

使用场景：黑名单，多线程爬虫，判断是否是黑名单中的链接或者已经爬过的链接。对于这些链接，只能插入，不能删除修改，给一个链接，只需判断是否在里面。

布隆过滤器可以极大减少黑名单的大小，但是会有误差，不会很大。

黑名单中的链接不会被误判成白的，但是白的有可能会误判成黑的。

实现原理，使用位图。

##### 1、位图：使用整型数组表示一个很长的比特数。

以 `int[]` 为例，一个int等于4字节，等于32bit。

1.   取某一位的状态

```
int numIndex = i / 32; // 第几个整数
int bitIndex = i % 32; // 整数的第几个位

int status = ( (arr[numIndex] >> bitIndex) & 1 );
```

2.   将某一位改为1

```
arr[numIndex] = arr[numIndex] | (1 << bitIndex);
```

3.   将某一位改为0

```
arr[numIndex] = arr[numIndex] & ( ~(1 << bitIndex) );
```

##### 2、布隆过滤器

使用一个m长度的位图作为记录，将URL的k个不同的哈希值模m，得到最多 k 个不同的数，将位图对应位上的位置标记。将所有URL都执行一遍上述操作就得到了一个布隆过滤器。

使用时同样计算URL的k个不同的哈希值的模，查看位图上的这些位置是否有没有被标记的，如果有没标记的，就不是黑名单中的，如果全部标记了，就认为是黑名单中的。

布隆过滤器的准确性首先取决于m的大小。如果m很小，全部标记了就没有作用了。如果很大效果会变低。

在m确定的情况下，k过小或者过大都会影响准确性。

公式计算：

假设样本量为 n，失误率控制在 p以内，则

位图的长度 $m = - \frac{nlnp}{(ln2)^2}$ ，

哈希函数的个数 $k = ln2 \frac{m}{n} \approx 0.7 \times \frac{m}{n} $ ，

如果实际给的空间比理论的要大，那么失误率会进一步降低，这时候

真实误差律 

$$ P_真 = (1- e^{- \frac{n \cdot k_真}{m_真}})^{k_真} $$

#### 2.1.3、哈希一致性

传统的后端项目使用一台强大的服务器存储数据库，多台逻辑服务器负责请求转发。后来形成分布式的数据库，当用户请求数据时，根据请求的哈希值进行选择哪一台分布式机器，遇到以下难题：

1.   服务器难以做到负载均衡，需要选择身份证号这样值有差异的字段作为计算哈希。
2.   在服务器增加或减少时，需要重新将所有数据计算哈希。

所以就有一种新的解决方式，将MD5哈希值看成一个首尾相接的环，用服务器的IP哈希值将整个哈希值范围分段，请求时定位到大于哈希值的最小值的服务器。但是这个方案还是有缺点。

1.   服务器较少时无法负载均衡。
2.   添加或删除时会打破平衡。

最终的解决方式是，使用虚拟IP的技术，给每一台服务器都分配很多个字段（几百几千），这样即使服务器很少，也可以较为均匀地划分不同的范围。增加或删除节点时，也不会破坏原来的负载均衡。只需要让逻辑服务器都存储一下不同服务器的范围即可。

这就是谷歌提出的哈希一致性，它是目前分布式系统的三大基础之一，所有的分布式系统都基于这个原理。
